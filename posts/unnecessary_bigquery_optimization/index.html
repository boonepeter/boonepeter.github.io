<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<title>Unnecessary BigQuery Optimization - Peter Boone</title>
<meta name=keywords content="tech,bigquery,google">
<meta name=description content="I was reading a post about BigQuery cost optimization which stated this:
 Also remember you are charged for bytes processed in the first stage of query execution. Avoid creating a complex multistage query just to optimize for bytes processed in the intermediate stages, since there are no cost implications anyway (though you may achieve performance gains).
 I was curious about this, because I have written some queries to minimize reading data multiple times.">
<meta name=author content="Peter Boone">
<link rel=canonical href=https://boonepeter.github.io/posts/unnecessary_bigquery_optimization/>
<link href=https://boonepeter.github.io/assets/css/stylesheet.min.69a0a2b5ef2f62289117c5e7895b832df501978d8dfb1274dc90509d9924b2bb.css integrity="sha256-aaCite8vYiiRF8XniVuDLfUBl42N+xJ03JBQnZkksrs=" rel="preload stylesheet" as=style>
<link rel=manifest href=https://boonepeter.github.io/site.webmanifest>
<link rel=icon href=https://boonepeter.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://boonepeter.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://boonepeter.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://boonepeter.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://boonepeter.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.88.1">
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-125699184-1','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
<meta property="og:title" content="Unnecessary BigQuery Optimization">
<meta property="og:description" content="I was reading a post about BigQuery cost optimization which stated this:
 Also remember you are charged for bytes processed in the first stage of query execution. Avoid creating a complex multistage query just to optimize for bytes processed in the intermediate stages, since there are no cost implications anyway (though you may achieve performance gains).
 I was curious about this, because I have written some queries to minimize reading data multiple times.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://boonepeter.github.io/posts/unnecessary_bigquery_optimization/">
<meta property="article:published_time" content="2021-09-12T00:00:00+00:00">
<meta property="article:modified_time" content="2021-09-12T00:00:00+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Unnecessary BigQuery Optimization">
<meta name=twitter:description content="I was reading a post about BigQuery cost optimization which stated this:
 Also remember you are charged for bytes processed in the first stage of query execution. Avoid creating a complex multistage query just to optimize for bytes processed in the intermediate stages, since there are no cost implications anyway (though you may achieve performance gains).
 I was curious about this, because I have written some queries to minimize reading data multiple times.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Unnecessary BigQuery Optimization","name":"Unnecessary BigQuery Optimization","description":"I was reading a post about BigQuery cost optimization which stated this:\n Also remember you are charged for bytes processed in the first stage of query execution. Avoid creating a …","keywords":["tech","bigquery","google"],"articleBody":"I was reading a post about BigQuery cost optimization which stated this:\n Also remember you are charged for bytes processed in the first stage of query execution. Avoid creating a complex multistage query just to optimize for bytes processed in the intermediate stages, since there are no cost implications anyway (though you may achieve performance gains).\n I was curious about this, because I have written some queries to minimize reading data multiple times. I decided to write two simple queries to test out documentation’s advice.\nQuery 1 - CTE WITH a AS ( SELECT invoice_and_item_number, vendor_name, zip_code FROM `bigquery-public-data.iowa_liquor_sales.sales` WHERE zip_code IN ('52722', '50314') ) SELECT COUNT(invoice_and_item_number) AS total_sales, '52722' AS zip FROM a WHERE zip_code = '52722' UNION ALL SELECT COUNT(invoice_and_item_number) AS total_sales, '50314' AS zip FROM a WHERE zip_code = '50314'; Query 2 - No CTE SELECT COUNT(invoice_and_item_number) AS total_sales, '52722' AS zip FROM `bigquery-public-data.iowa_liquor_sales.sales` WHERE zip_code = '52722' UNION ALL SELECT COUNT(invoice_and_item_number) AS total_sales, '50314' AS zip FROM `bigquery-public-data.iowa_liquor_sales.sales` WHERE zip_code = '50314'; I would think query 1 would be cheaper since it only reads the data once (in the CTE). Query 2 reads the data twice. But the BigQuery UI says that both queries process the same amount of data (476.4 MiB). I decided to look into the query plans to see how the executions compare.\nQuery 1 execution plan Let’s look at the execution plan for query 1. You can focus on S00 and S01 since the other stages are exactly the same between the two queries.\nS00: Input READ\t$10:invoice_and_item_number, $11:zip_code FROM bigquery-public-data.iowa_liquor_sales.sales WHERE and(in($11, '52722', '50314'), equal($11, '50314')) AGGREGATE\t$80 := COUNT($10) WRITE\t$80 TO __stage00_output S01: Input READ\t$1:invoice_and_item_number, $2:zip_code FROM bigquery-public-data.iowa_liquor_sales.sales WHERE and(in($2, '52722', '50314'), equal($2, '52722')) AGGREGATE\t$70 := COUNT($1) WRITE\t$70 TO __stage01_output S02: Aggregate+ READ\t$80 FROM __stage00_output COMPUTE\t$40 := '50314' AGGREGATE\t$60 := SUM_OF_COUNTS($80) WRITE\t$40, $60 TO __stage02_output S03: Aggregate+ READ\t$70 FROM __stage01_output COMPUTE\t$30 := '52722' AGGREGATE\t$50 := SUM_OF_COUNTS($70) WRITE\t$30, $50 TO __stage03_output S04: Output READ\t$30, $50 FROM __stage03_output READ\t$40, $60 FROM __stage02_output WRITE\t$20, $21 TO __stage04_output I was slighty supprised to see that there are two reads from the iowa_liquor_sales.sales table. I naively assumed that it would read data only once when it is selected in the CTE.\nQuery 2 execution plan S00: Input READ\t$10:invoice_and_item_number, $11:zip_code FROM bigquery-public-data.iowa_liquor_sales.sales WHERE equal($11, '50314') AGGREGATE\t$80 := COUNT($10) WRITE\t$80 TO __stage00_output S01: Input READ\t$1:invoice_and_item_number, $2:zip_code FROM bigquery-public-data.iowa_liquor_sales.sales WHERE equal($2, '52722') AGGREGATE\t$70 := COUNT($1) WRITE\t$70 TO __stage01_output [... ommiting the rest of the stages] Comparison As you can see, both plans read from the public dataset twice. The only difference between the two is in the WHERE clauses. The first query has redundant logic:\nWHERE and(in($11, '52722', '50314'), equal($11, '50314')) There is no need to check if the zip code is in ('52722', '50314') and also equal to 50314. Compare that to the second, more straightforwad WHERE clause:\nWHERE equal($11, '50314') Query 3 The first two queries prove a point - reading the same data twice from a table does not cost more. However, a better version of the query would be:\nSELECT zip_code, COUNT(invoice_and_item_number) AS total_sales, FROM `bigquery-public-data.iowa_liquor_sales.sales` WHERE zip_code in ('52722', '50314') GROUP BY zip_code; The amount of data processed is the same as the first two queries (476.4 MiB). However, the query plan is much simpler and only reads from the dataset once:\nS00: Input READ\t$1:invoice_and_item_number, $2:zip_code FROM bigquery-public-data.iowa_liquor_sales.sales WHERE in($2, '52722', '50314') AGGREGATE\tGROUP BY $30 := $2 $20 := COUNT($1) WRITE\t$30, $20 TO __stage00_output BY HASH($30) S01: Output READ\t$30, $20 FROM __stage00_output AGGREGATE\tGROUP BY $40 := $30 $10 := SUM_OF_COUNTS($20) WRITE\t$40, $10 TO __stage01_output Results    Query Bytes Processed Slot Time     Query 1 476.4 MiB 8.219 sec   Query 2 476.4 MiB 9.834 sec   Query 3 476.4 MiB 4.761 sec    As the documentation says, we shouldn’t worry about the number of times the data is read from a cost perspective. However, there may be performance gains if we can avoid reading the data multiple times. The last query consumes about 50% of the slot time of the first two queries. This is not a thorough comparison, but it does indicate that the third query is much faster.\nNote If you are using flat rate billing then you should be worried about the slot time from a cost perspective. As the post mentions:\n You might be tempted to think that you don’t have to worry about query optimizations with flat-rate at all. The reality is that it still impacts performance. The faster your query (job) executes, the more number of jobs you will be able to complete in the same amount of time with fixed slots. If you think about it, that’s cost optimization in itself!\n ","wordCount":"797","inLanguage":"en","datePublished":"2021-09-12T00:00:00Z","dateModified":"2021-09-12T00:00:00Z","author":{"@type":"Person","name":"Peter Boone"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://boonepeter.github.io/posts/unnecessary_bigquery_optimization/"},"publisher":{"@type":"Organization","name":"Peter Boone","logo":{"@type":"ImageObject","url":"https://boonepeter.github.io/favicon.ico"}}}</script>
</head>
<body class=single id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<noscript>
<style type=text/css>.theme-toggle,.top-link{display:none}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://boonepeter.github.io/ accesskey=h>Peter Boone</a>
<span class=logo-switches>
<span class=theme-toggle>
<a id=theme-toggle accesskey=t><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</a>
</span>
</span>
</div>
<ul class=menu id=menu onscroll=menu_on_scroll()>
<li>
<a href=https://boonepeter.github.io/archive/>
<span>
Archives
</span>
</a>
</li>
<li>
<a href=https://boonepeter.github.io/tags/>
<span>
Tags
</span>
</a>
</li>
<li>
<a href=https://buttondown.email/boonepeter>
<span>
Subscribe
</span>
</a>
</li></ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
Unnecessary BigQuery Optimization
</h1>
<div class=post-meta>
September 12, 2021&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Peter Boone
&nbsp;·&nbsp;<a href=https://github.com/boonepeter/boonepeter.github.io/blob/master/content/posts/unnecessary_bigquery_optimization.md>Source</a>
</div>
</header>
<div class=post-content>
<p>I was reading <a href=https://cloud.google.com/blog/products/data-analytics/cost-optimization-best-practices-for-bigquery>a post</a> about BigQuery cost optimization which stated this:</p>
<blockquote>
<p>Also remember you are charged for bytes processed in the <a href=https://cloud.google.com/bigquery/query-plan-explanation#background>first stage of query execution</a>. Avoid creating a complex multistage query just to optimize for bytes processed in the intermediate stages, since there are no cost implications anyway (though you may achieve performance gains).</p>
</blockquote>
<p>I was curious about this, because I have written some queries to minimize reading data multiple times. I decided to write two simple queries to test out documentation&rsquo;s advice.</p>
<h2 id=query-1---cte>Query 1 - CTE<a hidden class=anchor aria-hidden=true href=#query-1---cte>#</a></h2>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#66d9ef>WITH</span> a <span style=color:#66d9ef>AS</span> (
  <span style=color:#66d9ef>SELECT</span>
    invoice_and_item_number,
    vendor_name,
    zip_code
  <span style=color:#66d9ef>FROM</span> <span style=color:#f92672>`</span>bigquery<span style=color:#f92672>-</span><span style=color:#66d9ef>public</span><span style=color:#f92672>-</span><span style=color:#66d9ef>data</span>.iowa_liquor_sales.sales<span style=color:#f92672>`</span>
  <span style=color:#66d9ef>WHERE</span> zip_code <span style=color:#66d9ef>IN</span> (<span style=color:#e6db74>&#39;52722&#39;</span>, <span style=color:#e6db74>&#39;50314&#39;</span>) )
<span style=color:#66d9ef>SELECT</span>
  <span style=color:#66d9ef>COUNT</span>(invoice_and_item_number) <span style=color:#66d9ef>AS</span> total_sales,
  <span style=color:#e6db74>&#39;52722&#39;</span> <span style=color:#66d9ef>AS</span> zip
<span style=color:#66d9ef>FROM</span> a
<span style=color:#66d9ef>WHERE</span> zip_code <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;52722&#39;</span>
<span style=color:#66d9ef>UNION</span> <span style=color:#66d9ef>ALL</span>
<span style=color:#66d9ef>SELECT</span>
  <span style=color:#66d9ef>COUNT</span>(invoice_and_item_number) <span style=color:#66d9ef>AS</span> total_sales,
  <span style=color:#e6db74>&#39;50314&#39;</span> <span style=color:#66d9ef>AS</span> zip
<span style=color:#66d9ef>FROM</span> a
<span style=color:#66d9ef>WHERE</span> zip_code <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;50314&#39;</span>;
</code></pre></div><h2 id=query-2---no-cte>Query 2 - No CTE<a hidden class=anchor aria-hidden=true href=#query-2---no-cte>#</a></h2>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#66d9ef>SELECT</span>
  <span style=color:#66d9ef>COUNT</span>(invoice_and_item_number) <span style=color:#66d9ef>AS</span> total_sales,
  <span style=color:#e6db74>&#39;52722&#39;</span> <span style=color:#66d9ef>AS</span> zip
<span style=color:#66d9ef>FROM</span> <span style=color:#f92672>`</span>bigquery<span style=color:#f92672>-</span><span style=color:#66d9ef>public</span><span style=color:#f92672>-</span><span style=color:#66d9ef>data</span>.iowa_liquor_sales.sales<span style=color:#f92672>`</span>
<span style=color:#66d9ef>WHERE</span> zip_code <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;52722&#39;</span>
<span style=color:#66d9ef>UNION</span> <span style=color:#66d9ef>ALL</span>
<span style=color:#66d9ef>SELECT</span>
  <span style=color:#66d9ef>COUNT</span>(invoice_and_item_number) <span style=color:#66d9ef>AS</span> total_sales,
  <span style=color:#e6db74>&#39;50314&#39;</span> <span style=color:#66d9ef>AS</span> zip
<span style=color:#66d9ef>FROM</span> <span style=color:#f92672>`</span>bigquery<span style=color:#f92672>-</span><span style=color:#66d9ef>public</span><span style=color:#f92672>-</span><span style=color:#66d9ef>data</span>.iowa_liquor_sales.sales<span style=color:#f92672>`</span>
<span style=color:#66d9ef>WHERE</span> zip_code <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;50314&#39;</span>;
</code></pre></div><p>I would think query 1 would be cheaper since it only reads the data once (in the CTE). Query 2 reads the data twice. But the BigQuery UI says that both queries process the same amount of data (476.4 MiB). I decided to look into the query plans to see how the executions compare.</p>
<h2 id=query-1-execution-plan>Query 1 execution plan<a hidden class=anchor aria-hidden=true href=#query-1-execution-plan>#</a></h2>
<p>Let&rsquo;s look at the execution plan for query 1. You can focus on <code>S00</code> and <code>S01</code> since the other stages are exactly the same between the two queries.</p>
<pre tabindex=0><code>S00: Input
  READ	
    $10:invoice_and_item_number, $11:zip_code
    FROM bigquery-public-data.iowa_liquor_sales.sales
    WHERE and(in($11, '52722', '50314'), equal($11, '50314'))
  AGGREGATE	
    $80 := COUNT($10)
  WRITE	
    $80
    TO __stage00_output
S01: Input
  READ	
    $1:invoice_and_item_number, $2:zip_code
    FROM bigquery-public-data.iowa_liquor_sales.sales
    WHERE and(in($2, '52722', '50314'), equal($2, '52722'))
  AGGREGATE	
    $70 := COUNT($1)
  WRITE	
    $70
    TO __stage01_output
S02: Aggregate+
  READ	
    $80
    FROM __stage00_output
  COMPUTE	
    $40 := '50314'
  AGGREGATE	
    $60 := SUM_OF_COUNTS($80)
  WRITE	
    $40, $60
    TO __stage02_output
S03: Aggregate+
  READ	
    $70
    FROM __stage01_output
  COMPUTE	
    $30 := '52722'
  AGGREGATE	
    $50 := SUM_OF_COUNTS($70)
  WRITE	
    $30, $50
    TO __stage03_output
S04: Output
  READ	
    $30, $50
    FROM __stage03_output
  READ	
    $40, $60
    FROM __stage02_output
  WRITE	
    $20, $21
    TO __stage04_output
</code></pre><p>I was slighty supprised to see that there are two reads from the <code>iowa_liquor_sales.sales</code> table. I naively assumed that it would read data only once when it is selected in the CTE.</p>
<h2 id=query-2-execution-plan>Query 2 execution plan<a hidden class=anchor aria-hidden=true href=#query-2-execution-plan>#</a></h2>
<pre tabindex=0><code>S00: Input
  READ	
    $10:invoice_and_item_number, $11:zip_code
    FROM bigquery-public-data.iowa_liquor_sales.sales
    WHERE equal($11, '50314')
  AGGREGATE	
    $80 := COUNT($10)
  WRITE	
    $80
    TO __stage00_output

S01: Input
  READ	
    $1:invoice_and_item_number, $2:zip_code
    FROM bigquery-public-data.iowa_liquor_sales.sales
    WHERE equal($2, '52722')
  AGGREGATE	
    $70 := COUNT($1)
  WRITE	
    $70
    TO __stage01_output

[... ommiting the rest of the stages]
</code></pre><h2 id=comparison>Comparison<a hidden class=anchor aria-hidden=true href=#comparison>#</a></h2>
<p>As you can see, both plans read from the public dataset twice. The only difference between the two is in the <code>WHERE</code> clauses. The first query has redundant logic:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#66d9ef>WHERE</span> <span style=color:#66d9ef>and</span>(<span style=color:#66d9ef>in</span>(<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>11</span>, <span style=color:#e6db74>&#39;52722&#39;</span>, <span style=color:#e6db74>&#39;50314&#39;</span>), equal(<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>11</span>, <span style=color:#e6db74>&#39;50314&#39;</span>))
</code></pre></div><p>There is no need to check if the zip code is in <code>('52722', '50314')</code> and also equal to <code>50314</code>. Compare that to the second, more straightforwad <code>WHERE</code> clause:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#66d9ef>WHERE</span> equal(<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>11</span>, <span style=color:#e6db74>&#39;50314&#39;</span>)
</code></pre></div><h2 id=query-3>Query 3<a hidden class=anchor aria-hidden=true href=#query-3>#</a></h2>
<p>The first two queries prove a point - reading the same data twice from a table does not cost more. However, a better version of the query would be:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#66d9ef>SELECT</span>
  zip_code,
  <span style=color:#66d9ef>COUNT</span>(invoice_and_item_number) <span style=color:#66d9ef>AS</span> total_sales,
<span style=color:#66d9ef>FROM</span> <span style=color:#f92672>`</span>bigquery<span style=color:#f92672>-</span><span style=color:#66d9ef>public</span><span style=color:#f92672>-</span><span style=color:#66d9ef>data</span>.iowa_liquor_sales.sales<span style=color:#f92672>`</span>
<span style=color:#66d9ef>WHERE</span> zip_code <span style=color:#66d9ef>in</span> (<span style=color:#e6db74>&#39;52722&#39;</span>, <span style=color:#e6db74>&#39;50314&#39;</span>)
<span style=color:#66d9ef>GROUP</span> <span style=color:#66d9ef>BY</span> zip_code;
</code></pre></div><p>The amount of data processed is the same as the first two queries (476.4 MiB). However, the query plan is much simpler and only reads from the dataset once:</p>
<pre tabindex=0><code>S00: Input
  READ	
    $1:invoice_and_item_number, $2:zip_code
    FROM bigquery-public-data.iowa_liquor_sales.sales
    WHERE in($2, '52722', '50314')
  AGGREGATE	
    GROUP BY $30 := $2
    $20 := COUNT($1)
  WRITE	
    $30, $20
    TO __stage00_output
    BY HASH($30)
S01: Output
  READ	
    $30, $20
    FROM __stage00_output
  AGGREGATE	
    GROUP BY $40 := $30
    $10 := SUM_OF_COUNTS($20)
  WRITE	
    $40, $10
    TO __stage01_output
</code></pre><h2 id=results>Results<a hidden class=anchor aria-hidden=true href=#results>#</a></h2>
<table>
<thead>
<tr>
<th>Query</th>
<th>Bytes Processed</th>
<th>Slot Time</th>
</tr>
</thead>
<tbody>
<tr>
<td>Query 1</td>
<td>476.4 MiB</td>
<td>8.219 sec</td>
</tr>
<tr>
<td>Query 2</td>
<td>476.4 MiB</td>
<td>9.834 sec</td>
</tr>
<tr>
<td>Query 3</td>
<td>476.4 MiB</td>
<td>4.761 sec</td>
</tr>
</tbody>
</table>
<p>As the documentation says, we shouldn&rsquo;t worry about the number of times the data is read from a cost perspective. However, there may be performance gains if we can avoid reading the data multiple times. The last query consumes about 50% of the slot time of the first two queries. This is not a thorough comparison, but it does indicate that the third query is much faster.</p>
<h3 id=note>Note<a hidden class=anchor aria-hidden=true href=#note>#</a></h3>
<p>If you are using flat rate billing then you <strong>should</strong> be worried about the slot time from a cost perspective. As <a href="https://cloud.google.com/blog/products/data-analytics/cost-optimization-best-practices-for-bigquery#:~:text=You%20might%20be,optimization%20in%20itself!">the post mentions</a>:</p>
<blockquote>
<p>You might be tempted to think that you don’t have to worry about query optimizations with flat-rate at all. The reality is that it still impacts performance. The faster your query (job) executes, the more number of jobs you will be able to complete in the same amount of time with fixed slots. If you think about it, that’s cost optimization in itself!</p>
</blockquote>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://boonepeter.github.io/tags/tech>tech</a></li>
<li><a href=https://boonepeter.github.io/tags/bigquery>bigquery</a></li>
<li><a href=https://boonepeter.github.io/tags/google>google</a></li>
</ul>
</footer>
</article>
</main><footer class=footer>
<span>&copy; 2021 <a href=https://boonepeter.github.io/>Peter Boone</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span>
<span>&#183;</span>
<span><a href=https://buttondown.email/boonepeter>Subscribe</a></span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top" accesskey=g>
<button class=top-link id=top-link type=button><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script src=https://boonepeter.github.io/assets/js/highlight.min.727bc06f35142445e1ca4dbf0c258372d440dfd30ea831e99dbe7bf9e54d11da.js integrity="sha256-cnvAbzUUJEXhyk2/DCWDctRA39MOqDHpnb57+eVNEdo="></script>
<script>hljs.initHighlightingOnLoad()</script>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(a){a.preventDefault();var b=this.getAttribute("href").substr(1);document.querySelector(`[id='${b}']`).scrollIntoView({behavior:"smooth"})})});var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>