<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Spotify Codes - Part 2 - Peter Boone</title><meta name=keywords content="tech,spotify,python"><meta name=description content="In part 1 I dove into Spotify Codes and explained the general technical concepts of how they work. If you haven&rsquo;t read that post you should check it out. I shared it on reddit where it generated a lot of interesting discussion. Ludvig Strigeus, a key early developer at Spotify and the person who invented Spotify Codes, even stopped by and shared some more information on their creation and the rationale behind them!"><meta name=author content="Peter Boone"><link rel=canonical href=https://boonepeter.github.io/posts/spotify-codes-part-2/><link href=https://boonepeter.github.io/assets/css/stylesheet.min.69a0a2b5ef2f62289117c5e7895b832df501978d8dfb1274dc90509d9924b2bb.css integrity="sha256-aaCite8vYiiRF8XniVuDLfUBl42N+xJ03JBQnZkksrs=" rel="preload stylesheet" as=style><link rel=manifest href=https://boonepeter.github.io/site.webmanifest><link rel=icon href=https://boonepeter.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://boonepeter.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://boonepeter.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://boonepeter.github.io/apple-touch-icon.png><link rel=mask-icon href=https://boonepeter.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.111.3"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-125699184-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script><meta property="og:title" content="Spotify Codes - Part 2"><meta property="og:description" content="In part 1 I dove into Spotify Codes and explained the general technical concepts of how they work. If you haven&rsquo;t read that post you should check it out. I shared it on reddit where it generated a lot of interesting discussion. Ludvig Strigeus, a key early developer at Spotify and the person who invented Spotify Codes, even stopped by and shared some more information on their creation and the rationale behind them!"><meta property="og:type" content="article"><meta property="og:url" content="https://boonepeter.github.io/posts/spotify-codes-part-2/"><meta property="article:published_time" content="2021-11-11T00:00:00+00:00"><meta property="article:modified_time" content="2021-11-11T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Spotify Codes - Part 2"><meta name=twitter:description content="In part 1 I dove into Spotify Codes and explained the general technical concepts of how they work. If you haven&rsquo;t read that post you should check it out. I shared it on reddit where it generated a lot of interesting discussion. Ludvig Strigeus, a key early developer at Spotify and the person who invented Spotify Codes, even stopped by and shared some more information on their creation and the rationale behind them!"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Spotify Codes - Part 2","name":"Spotify Codes - Part 2","description":"In part 1 I dove into Spotify Codes and explained the general technical concepts of how they work. If you haven\u0026amp;rsquo;t read that post you should check it out. I shared it on …","keywords":["tech","spotify","python"],"articleBody":"\nIn part 1 I dove into Spotify Codes and explained the general technical concepts of how they work. If you haven’t read that post you should check it out. I shared it on reddit where it generated a lot of interesting discussion. Ludvig Strigeus, a key early developer at Spotify and the person who invented Spotify Codes, even stopped by and shared some more information on their creation and the rationale behind them!\nAt the end of part 1 I wrote that I wasn’t sure about some of the details, so I was not able to implement my own barcode to URI converter. Thanks to a little more digging and a lot of help from someone on Stack Overflow I can now do that conversion.\nThis article is going to be a little bit more technical than part 1 as I try to explain exactly how Spotify encodes their barcodes. I will include some more resources if you want to keep learning.\nEncoding a URI into a Spotify Barcode I find it easier to understand Spotify Barcodes by starting with the URI and working through the encoding process.\nMedia reference A media reference is first generated by Spotify for a Spotify URI. The media reference is what gets encoded into the barcode and links the barcode to the URI. Spotify maintains a database of media reference to URI mappings. Media references let Spotify track which codes are scanned, enable them to theoretically re-map codes, and just look better when encoded. If Spotify encoded a whole URI, it would look something like this (and would be harder to scan):\nLet’s start with the media reference 57639171874 which points to the following playlist: spotify:user:spotify:playlist:37i9dQZF1DWZq91oLsHZvy (Indie x Running).\nThe media reference can be expressed as a 37 bit binary number:\n57639171874 -\u003e 0100010011101111111100011101011010110 CRC Calculation Next, cyclic redundancy check bits are calculated for the media reference. A CRC calculates check bits to verify the integrity of the data. (Tangent: another simple checksum algorithm we use every day to validate credit card numbers is the Luhn algorithm.)\nSpotify uses CRC-8 with the following generator:\nx^8 + x^2 + x + 1 Which gives us the following polynomial when fully written out:\n1x^8 + 0x^7 + 0x^6 + 0x^5 + 0x^4 + 0x^3 + 1x^2 + x + 1 [1, 0, 0, 0, 0, 0, 1, 1, 1] The CRC is calculated by following these steps:\nPad with 3 bits on the right 01000100 11101111 11110001 11010110 10110000 Reverse bytes 00100010 11110111 10001111 01101011 00001101 Calculate CRC as normal (highest order degree on the left) 11001100 Reverse CRC 00110011 Invert check 11001100 Finally append to step 1 result 01000100 11101111 11110001 11010110 10110110 01100\r|----------Media Ref--------------------||--CRC--| Here is a simple version of a crc calculator (step 3):\ndef crc(data, polynomial): # xor the data with the polynomial at each occurrence of # a 1 in the data. Return the remainder as the checksum. n = len(polynomial) - 1 initial_length = len(data) check_bits = data + [0] * n for i in range(initial_length): if check_bits[i] == 1: for j, p in enumerate(polynomial): check_bits[i + j] = check_bits[i + j] ^ p return check_bits[-n:] We can use the check bits to verify that the contents of the data match what was intended by the “sender”:\ndef check_crc(data, polynomial, check_bits): full_data = data + check_bits for i in range(len(data)): if full_data[i] == 1: for j, p in enumerate(polynomial): full_data[i + j] = full_data[i + j] ^ p return 1 not in full_data data = [0,0,1,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,0,1,1,0,1] check = [1,1,0,0,1,1,0,0] poly = [1,0,0,0,0,0,1,1,1] print(check_crc(data, poly, check)) # True Convolutional encoding These 45 bits are then convolutionally encoded. Convolutional codes add redundancy to data to make it possible to decode the data if errors are introduced during transmission. I recommend you check out these MIT lecture notes to learn more about convolutional codes.\nSpotify’s patent is not very clear on what convolutional encoding is performed:\nThe code can then be transformed into an error correcting code, such as a forward error correcting code. The forward error correction used can, for example, be a convolutional code.\nHowever, “Doyle” on Stack Overflow identified that Spotify uses the following generator polynomials:\ng0 = 1011011\rg1 = 1111001 The generator polynomial represents which bits of the input should be XOR’ed together in a sliding window.\nTail biting Before we start calculating the parity bits, we must prepend stream with last 6 bits of data:\n01000100 11101111 11110001 11010110 10110110 01100\r|-----|\r001100 01000100 11101111 11110001 11010110 10110110 01100\r|----| Another approach would be to prepend 0s to the input, but Spotify chose to go with this tail-biting method.\nEncoding We can focus on one generator at a time. Below is a step by step walkthrough of how the parity bits are generated for g0. I reversed the polynomial because it is easier to display right to left in the example.\nBit #0\r001100010001001110111111110001110101101011011001100\r1101101 \u003c- generator polynomial (mask)\r-------\r0001000 = 1 (xor the bits together)\rBit #1\r001100010001001110111111110001110101101011011001100\r1101101 \u003c- generator polynomial (mask)\r-------\r0100001 = 0 (xor the bits together)\rBit #2\r001100010001001110111111110001110101101011011001100\r1101101 \u003c- generator polynomial (mask)\r-------\r1100000 = 0 (xor the bits together)\rBit #3\r001100010001001110111111110001110101101011011001100\r1101101 \u003c- generator polynomial (mask)\r-------\r1000100 = 0 (xor the bits together)\rBit #4\r001100010001001110111111110001110101101011011001100\r1101101 \u003c- generator polynomial (mask)\r-------\r0001000 = 1 (xor the bits together) Continue this to the end of the stream of input bits:\nBit #45\r001100010001001110111111110001110101101011011001100\r1101101 \u003c- generator polynomial (mask)\r-------\r1001100 = 1 (xor the bits together) The result of encoding with the first generator, g0:\n100011100111110100110011110100000010001001011 The result of encoding with g1:\n110011100010110110110100101101011100110011011 Here is a (naive) algorithm for calculating the parity bits:\ndef encode(bits: List[int], polynomial: List[int], tail_bite=False): \"\"\"Convolutionally encode the stream of bits using the generator polynomial. If tail_bite == True, prepend the tail of the input. Otherwise use 0s to fill. \"\"\" if tail_bite: tail = bits[-(len(polynomial) - 1):] else: tail = [0 for i in range(len(polynomial) - 1)] full = tail + bits polynomial.reverse() # Reverse since we're working the other direction parity_bits = [] for i in range(len(bits)): parity = 0 for j in range(len(polynomial)): parity ^= full[i + j] * polynomial[j] parity_bits.append(parity) return parity_bits These two parity bit sequences are then interleaved (abab…):\n1 0 0 0 1 1 1 0 0 1 1 1 1 1 0 1 0 0 1 1 0 0 1 1 1 1 0 1 0 0 0 0 0 0 1 0 0 0 1 0 0 1 0 1 1\r1 1 0 0 1 1 1 0 0 0 1 0 1 1 0 1 1 0 1 1 0 1 0 0 1 0 1 1 0 1 0 1 1 1 0 0 1 1 0 0 1 1 0 1 1\rresult:\r110100001111110000101110111100110100111100011010111001110001000101011000010110000111001111 Puncturing At this point we have gone from 45 bits to 90 bits. The rate of this convolutional code is 1/2 (one input bit results in 2 parity bits).\nA rate of 1/2 is actually somewhat low for this application (see this article about QR code rates). The rate can be increased by “puncturing” the code. We can remove every third bit to increase the rate to 3/4:\n110100001111110000101110111100110100111100011010111001110001000101011000010110000111001111\r11 10 00 11 11 00 10 11 11 10 11 10 11 10 01 01 11 00 11 00 00 10 01 00 01 11 00 11 00 11\rresult:\r111000111100101111101110111001011100110000100100011100110011 This is equivalent to puncturing the two parity bit sequences with the patterns 101 and 110 before interleaving. Puncturing is a nice, simple way to increase the rate of your code after you estimate the frequency of expected errors.\nPermutation Spotify then shuffles the data to spread out errors when a whole bar is lost:\nA shuffling process may be used to spread out the potential errors (e.g., if a whole bar/distance is missing). Instead of having the encoded bar lengths be consecutive, the lost bits are non-consecutive in the code word. This improves the chances for the forward error correction to work when a whole bar or distance is lost. Thus to scan the optical code, after the lengths of the found bars are converted into bits with certainties, the bits are shuffled back into the right order.\nsource\nThe bits are permuted by choosing every 7th bit (modulo 60) from the input.\ndef permute(bits, step=7): for i in range(len(bits)): yield bits[(i * step) % len(bits)] Input and result:\n111000111100101111101110111001011100110000100100011100110011\r111100110001110101101000011110010110101100111111101000111000 Map to bar heights Finally, map the bits to bar heights between 0 and 7 using gray code:\nDecimal Binary Gray 0 000 000 1 001 001 2 010 011 3 011 010 4 100 110 5 101 111 6 110 101 7 111 100 111 100 110 001 110 101 101 000 011 110 010 110 101 100 111 111 101 000 111 000\r5 7 4 1 4 6 6 0 2 4 3 4 6 7 5 5 6 0 7 0 Three additional bars are added as reference points at the start, end, and 12th position:\n[0]5741466024[7]3467556070[0] Which gives us the resulting Spotify code: Decoding Let’s reiterate why we went through the process of calculating the CRC and convolutionally encoding the data:\nConvolutional codes allow us to correct for errors in a message by sending “redundant” bits with the message The CRC lets the client check the validity of the decoded Spotify code. If the check bits are not correct, the client can scan the code again. When they are correct, then the client can ping Spotify’s servers. As Ludvig says, “I chose to include a CRC to let the client have a way to more easily discard invalid codes without a backend roundtrip.” The process of transforming an image of a Spotify code to a media reference follows approximately the same steps as encoding in reverse. However, there is a good bit of theory around decoding a convolutional code.\nConvolutional decoding A deep dive into the various algorithms used to decode a convolutional code is beyond the scope of this article. However, I’d highly recommend you check out these MIT lecture notes on the Viterbi algorithm to learn more about one of these algorithms. Briefly, the algorithm provides a way of determining the most likely original sequence from the parity bit streams. This trellis diagram is a visual representation of the algorithm - finding the path with the least number of errors through the parity bit streams.\nWorking solution If you’d like to see a working decoder, you can check out the code here. You will need to get your personal access token from Spotify because the code has to ping their media_ref -\u003e uri look-up server. The code utilizes Doyle’s linear algebra solution, so if you are into that you can check that out.\nI validated this solution on a few more Spotify codes:\nheights: [0, 6, 6, 0, 7, 6, 0, 2, 2, 3, 1, 7, 0, 7, 6, 4, 6, 1, 4, 7, 4, 1, 0]\rmedia ref: 26560102031\ruri: spotify:track:1ykrctzPhcSS9GS3aHdtMt heights: [0, 2, 6, 7, 1, 7, 0, 0, 0, 0, 4, 7, 1, 7, 3, 4, 2, 7, 5, 6, 5, 6, 0]\ruri: spotify:user:jimmylavallin:playlist:2hXLRTDrNa4rG1XyM0ngT1\rmedia ref: 67775490487 heights: [0, 5, 7, 4, 1, 4, 6, 6, 0, 2, 4, 7, 3, 4, 6, 7, 5, 5, 6, 0, 5, 0, 0]\ruri: spotify:user:spotify:playlist:37i9dQZF1DWZq91oLsHZvy\rmedia ref: 57639171874 standard forward dynamic programming solution to maximum-likelihood decoding of a discrete-time, finite-state dynamical system observed in memoryless noise I had to laugh at a sentence I came across in an article about the Viterbi Algorithm:\nShortly afterward, in a paper submitted in May 1968 [23], Jim Omura observed that the VA [Viterbi Algorithm] was simply the standard forward dynamic programming solution to maximum-likelihood decoding of a discrete-time, finite-state dynamical system observed in memoryless noise.\nI’m not sure about you, but I would not describe “the standard forward dynamic programming solution to maximum-likelihood decoding of a discrete-time, finite-state dynamical system observed in memoryless noise” with the word “simple”.\nMy goal for this article was to try to explain the Spotify Codes encoding process in an approachable way. If you have any questions please reach out and ask for clarification!\nFurther Reading CRC Rocksoft\nReed-Solomon Codes and the Exploration of the Solar System\nHigh-Rate Punctured Convolutional Codes for Soft Decision Viterbi Decoding\nViterbi Decoding of Convolutional Codes\nConvolutional codes (MIT lecture notes)\nViterbi Decoder\nPunctured Convolutional Encoding\nPerformance of concatenated codes for deep space missions\nConvolutional Codes and State Machine View/Trellis (MIT Slides)\nThe Error Correcting Codes Page\nExplanation on Math Stack Exchange\nКак спрятать мусор в базе Spotify и превратить это в квест (How to hide trash in Spotify database and turn it into a quest)\nCracking Spotify Codes and making a quest out of it\n","wordCount":"2132","inLanguage":"en","datePublished":"2021-11-11T00:00:00Z","dateModified":"2021-11-11T00:00:00Z","author":{"@type":"Person","name":"Peter Boone"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://boonepeter.github.io/posts/spotify-codes-part-2/"},"publisher":{"@type":"Organization","name":"Peter Boone","logo":{"@type":"ImageObject","url":"https://boonepeter.github.io/favicon.ico"}}}</script></head><body class=single id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://boonepeter.github.io/ accesskey=h>Peter Boone</a>
<span class=logo-switches><span class=theme-toggle><a id=theme-toggle accesskey=t><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></span></div><ul class=menu id=menu onscroll=menu_on_scroll()><li><a href=https://boonepeter.github.io/archive/><span>Archives</span></a></li><li><a href=https://boonepeter.github.io/tags/><span>Tags</span></a></li><li><a href=https://buttondown.email/boonepeter><span>Subscribe</span></a></li><li><a href=https://boonepeter.github.io/resume/><span>Resume</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Spotify Codes - Part 2</h1><div class=post-meta>November 11, 2021 · 11 min · Peter Boone
&nbsp;·&nbsp;<a href=https://github.com/boonepeter/boonepeter.github.io/blob/master/content/posts/spotify-codes-part-2.md>Source</a></div></header><div class=post-content><p><img src=/imgs/spotify-2/spotify_track_6vQN2a9QSgWcm74KEZYfDL_labeled.png alt="spotify code with heights labeled"></p><p>In <a href=/posts/2020-11-10-spotify-codes>part 1</a> I dove into Spotify Codes and explained the general technical concepts of how they work. If you haven&rsquo;t read that post you should check it out. I <a href=https://www.reddit.com/r/programming/comments/jvrpvj/how_spotify_codes_work/>shared it on reddit</a> where it generated a lot of interesting discussion. <a href=https://en.wikipedia.org/wiki/Ludvig_Strigeus>Ludvig Strigeus</a>, a key early developer at Spotify and the person who invented Spotify Codes, even stopped by and shared some more information on their creation and the rationale behind them!</p><p>At the end of part 1 I wrote that I wasn&rsquo;t sure about some of the details, so I was not able to implement my own barcode to URI converter. Thanks to a little more digging and a <a href=https://stackoverflow.com/a/64950150/10703868>lot of help from someone on Stack Overflow</a> I can now do that conversion.</p><p>This article is going to be a little bit more technical than part 1 as I try to explain <em>exactly</em> how Spotify encodes their barcodes. I will include some more resources if you want to keep learning.</p><h2 id=encoding-a-uri-into-a-spotify-barcode>Encoding a URI into a Spotify Barcode<a hidden class=anchor aria-hidden=true href=#encoding-a-uri-into-a-spotify-barcode>#</a></h2><p>I find it easier to understand Spotify Barcodes by starting with the URI and working through the encoding process.</p><h3 id=media-reference>Media reference<a hidden class=anchor aria-hidden=true href=#media-reference>#</a></h3><p>A media reference is first <a href=https://www.spotifycodes.com/#create>generated by Spotify</a> for a Spotify URI. The media reference is what gets encoded into the barcode and links the barcode to the URI. Spotify maintains a database of media reference to URI mappings. Media references let Spotify track which codes are scanned, enable them to theoretically re-map codes, and just <strong>look</strong> better when encoded. If Spotify encoded a whole URI, it would look something like this (and would be harder to scan):</p><p><img src=https://i.imgur.com/eoX8nUF.png alt="long spotify code"></p><p>Let&rsquo;s start with the media reference <code>57639171874</code> which points to the following playlist: <code>spotify:user:spotify:playlist:37i9dQZF1DWZq91oLsHZvy</code> (<a href=https://open.spotify.com/playlist/37i9dQZF1DWZq91oLsHZvy>Indie x Running</a>).</p><p>The media reference can be expressed as a 37 bit binary number:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ae81ff>57639171874</span> <span style=color:#f92672>-&gt;</span> <span style=color:#ae81ff>0100010011101111111100011101011010110</span>
</span></span></code></pre></div><h3 id=crc-calculation>CRC Calculation<a hidden class=anchor aria-hidden=true href=#crc-calculation>#</a></h3><p>Next, <a href=https://en.wikipedia.org/wiki/Cyclic_redundancy_check>cyclic redundancy check</a> bits are calculated for the media reference. A CRC calculates check bits to verify the integrity of the data. (Tangent: another simple checksum algorithm we use every day to validate credit card numbers is the <a href=https://en.wikipedia.org/wiki/Luhn_algorithm>Luhn algorithm</a>.)</p><p>Spotify uses CRC-8 with the following generator:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>x^8 + x^2 + x + 1
</span></span></code></pre></div><p>Which gives us the following polynomial when fully written out:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>1x^8 + 0x^7 + 0x^6 + 0x^5 + 0x^4 + 0x^3 + 1x^2 + x + 1
</span></span><span style=display:flex><span>[1, 0, 0, 0, 0, 0, 1, 1, 1]
</span></span></code></pre></div><p>The CRC is calculated by following these steps:</p><ol><li>Pad with 3 bits on the right</li></ol><pre tabindex=0><code>01000100 11101111 11110001 11010110 10110000
</code></pre><ol start=2><li>Reverse bytes</li></ol><pre tabindex=0><code>00100010 11110111 10001111 01101011 00001101
</code></pre><ol start=3><li>Calculate CRC as normal (highest order degree on the left)</li></ol><pre tabindex=0><code>11001100
</code></pre><ol start=4><li>Reverse CRC</li></ol><pre tabindex=0><code>00110011
</code></pre><ol start=5><li>Invert check</li></ol><pre tabindex=0><code>11001100
</code></pre><ol start=6><li>Finally append to step 1 result</li></ol><pre tabindex=0><code>01000100 11101111 11110001 11010110 10110110 01100
|----------Media Ref--------------------||--CRC--|
</code></pre><p>Here is a simple version of a crc calculator (step 3):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>crc</span>(data, polynomial):
</span></span><span style=display:flex><span>    <span style=color:#75715e># xor the data with the polynomial at each occurrence of </span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># a 1 in the data. Return the remainder as the checksum.</span>
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> len(polynomial) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    initial_length <span style=color:#f92672>=</span> len(data)
</span></span><span style=display:flex><span>    check_bits <span style=color:#f92672>=</span> data <span style=color:#f92672>+</span> [<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> n
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(initial_length):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> check_bits[i] <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> j, p <span style=color:#f92672>in</span> enumerate(polynomial):
</span></span><span style=display:flex><span>                check_bits[i <span style=color:#f92672>+</span> j] <span style=color:#f92672>=</span> check_bits[i <span style=color:#f92672>+</span> j] <span style=color:#f92672>^</span> p
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> check_bits[<span style=color:#f92672>-</span>n:]
</span></span></code></pre></div><p>We can use the check bits to verify that the contents of the data match what was intended by the &ldquo;sender&rdquo;:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>check_crc</span>(data, polynomial, check_bits):
</span></span><span style=display:flex><span>    full_data <span style=color:#f92672>=</span> data <span style=color:#f92672>+</span> check_bits
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(data)):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> full_data[i] <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> j, p <span style=color:#f92672>in</span> enumerate(polynomial):
</span></span><span style=display:flex><span>                full_data[i <span style=color:#f92672>+</span> j] <span style=color:#f92672>=</span> full_data[i <span style=color:#f92672>+</span> j] <span style=color:#f92672>^</span> p
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> full_data
</span></span><span style=display:flex><span>data <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>check <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>poly <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>print(check_crc(data, poly, check))
</span></span><span style=display:flex><span><span style=color:#75715e># True</span>
</span></span></code></pre></div><h3 id=convolutional-encoding>Convolutional encoding<a hidden class=anchor aria-hidden=true href=#convolutional-encoding>#</a></h3><p>These 45 bits are then <a href=https://en.wikipedia.org/wiki/Convolutional_code>convolutionally encoded</a>. Convolutional codes add redundancy to data to make it possible to decode the data if errors are introduced during transmission. I recommend you check out <a href=http://web.mit.edu/6.02/www/f2010/handouts/lectures/L8.pdf>these MIT lecture notes</a> to learn more about convolutional codes.</p><p>Spotify&rsquo;s <a href=https://www.freepatentsonline.com/20180181849.pdf>patent</a> is not very clear on what convolutional encoding is performed:</p><blockquote><p>The code can then be transformed into an error correcting code, such as a forward error correcting code. The forward error correction used can, for example, be a convolutional code.</p></blockquote><p>However, &ldquo;Doyle&rdquo; on Stack Overflow <a href=https://stackoverflow.com/a/64950150/10703868>identified</a> that Spotify uses the following generator polynomials:</p><pre tabindex=0><code>g0 = 1011011
g1 = 1111001
</code></pre><p>The generator polynomial represents which bits of the input should be XOR&rsquo;ed together in a sliding window.</p><h4 id=tail-biting>Tail biting<a hidden class=anchor aria-hidden=true href=#tail-biting>#</a></h4><p>Before we start calculating the parity bits, we must prepend stream with last 6 bits of data:</p><pre tabindex=0><code>01000100 11101111 11110001 11010110 10110110 01100
                                           |-----|

001100 01000100 11101111 11110001 11010110 10110110 01100
|----|
</code></pre><p>Another approach would be to prepend <code>0</code>s to the input, but Spotify chose to go with this tail-biting method.</p><h4 id=encoding>Encoding<a hidden class=anchor aria-hidden=true href=#encoding>#</a></h4><p>We can focus on one generator at a time. Below is a step by step walkthrough of how the parity bits are generated for <code>g0</code>. I reversed the polynomial because it is easier to display right to left in the example.</p><pre tabindex=0><code>Bit #0
001100010001001110111111110001110101101011011001100
1101101 &lt;- generator polynomial (mask)
-------
0001000 = 1 (xor the bits together)

Bit #1
001100010001001110111111110001110101101011011001100
 1101101 &lt;- generator polynomial (mask)
 -------
 0100001 = 0 (xor the bits together)

Bit #2
001100010001001110111111110001110101101011011001100
  1101101 &lt;- generator polynomial (mask)
  -------
  1100000 = 0 (xor the bits together)

Bit #3
001100010001001110111111110001110101101011011001100
   1101101 &lt;- generator polynomial (mask)
   -------
   1000100 = 0 (xor the bits together)

Bit #4
001100010001001110111111110001110101101011011001100
    1101101 &lt;- generator polynomial (mask)
    -------
    0001000 = 1 (xor the bits together)
</code></pre><p>Continue this to the end of the stream of input bits:</p><pre tabindex=0><code>Bit #45
001100010001001110111111110001110101101011011001100
                                            1101101 &lt;- generator polynomial (mask)
                                            -------
                                            1001100 = 1 (xor the bits together)
</code></pre><p>The result of encoding with the first generator, <code>g0</code>:</p><pre tabindex=0><code>100011100111110100110011110100000010001001011
</code></pre><p>The result of encoding with <code>g1</code>:</p><pre tabindex=0><code>110011100010110110110100101101011100110011011
</code></pre><p>Here is a (naive) algorithm for calculating the parity bits:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>encode</span>(bits: List[int], polynomial: List[int], tail_bite<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;Convolutionally encode the stream of bits using the generator polynomial.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    If tail_bite == True, prepend the tail of the input. Otherwise use 0s to fill.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> tail_bite:
</span></span><span style=display:flex><span>        tail <span style=color:#f92672>=</span> bits[<span style=color:#f92672>-</span>(len(polynomial) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>):]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>: 
</span></span><span style=display:flex><span>        tail <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span> <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(polynomial) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span>    full <span style=color:#f92672>=</span> tail <span style=color:#f92672>+</span> bits
</span></span><span style=display:flex><span>    polynomial<span style=color:#f92672>.</span>reverse() <span style=color:#75715e># Reverse since we&#39;re working the other direction</span>
</span></span><span style=display:flex><span>    parity_bits <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(bits)):
</span></span><span style=display:flex><span>        parity <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> range(len(polynomial)):
</span></span><span style=display:flex><span>            parity <span style=color:#f92672>^=</span> full[i <span style=color:#f92672>+</span> j] <span style=color:#f92672>*</span> polynomial[j]
</span></span><span style=display:flex><span>        parity_bits<span style=color:#f92672>.</span>append(parity)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> parity_bits
</span></span></code></pre></div><p>These two parity bit sequences are then interleaved (abab&mldr;):</p><pre tabindex=0><code>1 0 0 0 1 1 1 0 0 1 1 1 1 1 0 1 0 0 1 1 0 0 1 1 1 1 0 1 0 0 0 0 0 0 1 0 0 0 1 0 0 1 0 1 1
 1 1 0 0 1 1 1 0 0 0 1 0 1 1 0 1 1 0 1 1 0 1 0 0 1 0 1 1 0 1 0 1 1 1 0 0 1 1 0 0 1 1 0 1 1
result:
110100001111110000101110111100110100111100011010111001110001000101011000010110000111001111
</code></pre><h4 id=puncturing>Puncturing<a hidden class=anchor aria-hidden=true href=#puncturing>#</a></h4><p>At this point we have gone from 45 bits to 90 bits. The rate of this convolutional code is 1/2 (one input bit results in 2 parity bits).</p><p>A rate of 1/2 is actually somewhat <strong>low</strong> for this application (see <a href=https://blog.qrstuff.com/2011/12/14/qr-code-error-correction>this article</a> about QR code rates). The rate can be increased by &ldquo;puncturing&rdquo; the code. We can remove every third bit to increase the rate to 3/4:</p><pre tabindex=0><code>110100001111110000101110111100110100111100011010111001110001000101011000010110000111001111
11 10 00 11 11 00 10 11 11 10 11 10 11 10 01 01 11 00 11 00 00 10 01 00 01 11 00 11 00 11
result:
111000111100101111101110111001011100110000100100011100110011
</code></pre><p>This is equivalent to puncturing the two parity bit sequences with the patterns <code>101</code> and <code>110</code> before interleaving. Puncturing is a nice, simple way to increase the rate of your code after you estimate the frequency of expected errors.</p><h4 id=permutation>Permutation<a hidden class=anchor aria-hidden=true href=#permutation>#</a></h4><p>Spotify then shuffles the data to spread out errors when a whole bar is lost:</p><blockquote><p>A shuffling process may be used to spread out the potential errors (e.g., if a whole bar/distance is missing). Instead of having the encoded bar lengths be consecutive, the lost bits are non-consecutive in the code word. This improves the chances for the forward error correction to work when a whole bar or distance is lost. Thus to scan the optical code, after the lengths of the found bars are converted into bits with certainties, the bits are shuffled back into the right order.</p></blockquote><p><a href=https://www.freepatentsonline.com/20180181849.pdf>source</a></p><p>The bits are permuted by choosing every 7th bit (modulo 60) from the input.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>permute</span>(bits, step<span style=color:#f92672>=</span><span style=color:#ae81ff>7</span>):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(bits)):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>yield</span> bits[(i <span style=color:#f92672>*</span> step) <span style=color:#f92672>%</span> len(bits)]
</span></span></code></pre></div><p>Input and result:</p><pre tabindex=0><code>111000111100101111101110111001011100110000100100011100110011
111100110001110101101000011110010110101100111111101000111000
</code></pre><h4 id=map-to-bar-heights>Map to bar heights<a hidden class=anchor aria-hidden=true href=#map-to-bar-heights>#</a></h4><p>Finally, map the bits to bar heights between 0 and 7 using <a href=https://en.wikipedia.org/wiki/Gray_code>gray code</a>:</p><table><thead><tr><th>Decimal</th><th>Binary</th><th>Gray</th></tr></thead><tbody><tr><td>0</td><td>000</td><td>000</td></tr><tr><td>1</td><td>001</td><td>001</td></tr><tr><td>2</td><td>010</td><td>011</td></tr><tr><td>3</td><td>011</td><td>010</td></tr><tr><td>4</td><td>100</td><td>110</td></tr><tr><td>5</td><td>101</td><td>111</td></tr><tr><td>6</td><td>110</td><td>101</td></tr><tr><td>7</td><td>111</td><td>100</td></tr></tbody></table><pre tabindex=0><code>111 100 110 001 110 101 101 000 011 110 010 110 101 100 111 111 101 000 111 000
 5   7   4   1   4   6   6   0   2   4   3   4   6   7   5   5   6   0   7   0
</code></pre><p>Three additional bars are added as reference points at the start, end, and 12th position:</p><pre tabindex=0><code>[0]5741466024[7]3467556070[0]
</code></pre><p>Which gives us the resulting Spotify code:
<img src=/imgs/spotify-2/spcode-37i9dQZF1DWZq91oLsHZvy_labeled.png alt="Spotify code for indie running playlist"></p><h2 id=decoding>Decoding<a hidden class=anchor aria-hidden=true href=#decoding>#</a></h2><p>Let&rsquo;s reiterate why we went through the process of calculating the CRC and convolutionally encoding the data:</p><ol><li>Convolutional codes allow us to correct for errors in a message by sending &ldquo;redundant&rdquo; bits with the message</li><li>The CRC lets the client check the validity of the decoded Spotify code. If the check bits are not correct, the client can scan the code again. When they are correct, then the client can ping Spotify&rsquo;s servers. As Ludvig says, &ldquo;I chose to include a CRC to let the client have a way to more easily discard invalid codes without a backend roundtrip.&rdquo;</li></ol><p>The process of transforming an image of a Spotify code to a media reference follows approximately the same steps as encoding in reverse. However, there is a good bit of theory around decoding a convolutional code.</p><h3 id=convolutional-decoding>Convolutional decoding<a hidden class=anchor aria-hidden=true href=#convolutional-decoding>#</a></h3><p>A deep dive into the various algorithms used to decode a convolutional code is beyond the scope of this article. However, I&rsquo;d highly recommend you check out <a href=http://web.mit.edu/6.02/www/s2012/handouts/8.pdf>these MIT lecture notes on the Viterbi algorithm</a> to learn more about one of these algorithms. Briefly, the algorithm provides a way of determining the <em>most likely</em> original sequence from the parity bit streams. This trellis diagram is a visual representation of the algorithm - finding the path with the least number of errors through the parity bit streams.</p><p><img src=/imgs/spotify-2/trellis_diagram.png alt="trellis diagram to illustrate the Viterbi algorithm"></p><h2 id=working-solution>Working solution<a hidden class=anchor aria-hidden=true href=#working-solution>#</a></h2><p>If you&rsquo;d like to see a working decoder, you can check out the <a href=https://github.com/boonepeter/boonepeter.github.io-code/tree/main/spotify-codes-part-2>code here</a>. You will need to get your personal access token from Spotify because the code has to ping their <code>media_ref -> uri</code> look-up server. The code utilizes Doyle&rsquo;s linear algebra solution, so if you are into that you can check that out.</p><p>I validated this solution on a few more Spotify codes:</p><p><img src=/imgs/spotify-2/spotify_track_1ykrctzPhcSS9GS3aHdtMt.jpeg alt="joker presents"></p><pre tabindex=0><code>heights: [0, 6, 6, 0, 7, 6, 0, 2, 2, 3, 1, 7, 0, 7, 6, 4, 6, 1, 4, 7, 4, 1, 0]
media ref: 26560102031
uri: spotify:track:1ykrctzPhcSS9GS3aHdtMt
</code></pre><p><img src=/imgs/spotify-2/spotify_user_jimmylavallin_playlist_2hXLRTDrNa4rG1XyM0ngT1.jpeg alt="jimmy&amp;rsquo;s stuff"></p><pre tabindex=0><code>heights: [0, 2, 6, 7, 1, 7, 0, 0, 0, 0, 4, 7, 1, 7, 3, 4, 2, 7, 5, 6, 5, 6, 0]
uri: spotify:user:jimmylavallin:playlist:2hXLRTDrNa4rG1XyM0ngT1
media ref: 67775490487
</code></pre><p><img src=/imgs/spotify-2/spotify_user_spotify_playlist_37i9dQZF1DWZq91oLsHZvy.jpeg alt="indie kicks"></p><pre tabindex=0><code>heights: [0, 5, 7, 4, 1, 4, 6, 6, 0, 2, 4, 7, 3, 4, 6, 7, 5, 5, 6, 0, 5, 0, 0]
uri: spotify:user:spotify:playlist:37i9dQZF1DWZq91oLsHZvy
media ref: 57639171874
</code></pre><h2 id=standard-forward-dynamic-programming-solution-to-maximum-likelihood-decoding-of-a-discrete-time-finite-state-dynamical-system-observed-in-memoryless-noise>standard forward dynamic programming solution to maximum-likelihood decoding of a discrete-time, finite-state dynamical system observed in memoryless noise<a hidden class=anchor aria-hidden=true href=#standard-forward-dynamic-programming-solution-to-maximum-likelihood-decoding-of-a-discrete-time-finite-state-dynamical-system-observed-in-memoryless-noise>#</a></h2><p>I had to laugh at a sentence I came across in an <a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.341.7314&amp;rep=rep1&amp;type=pdf">article</a> about the Viterbi Algorithm:</p><blockquote><p>Shortly afterward, in a paper submitted in May 1968 [23], Jim Omura observed that the VA [Viterbi Algorithm] was
<strong>simply</strong> the standard forward dynamic programming solution to maximum-likelihood decoding
of a discrete-time, finite-state dynamical system observed in memoryless noise.</p></blockquote><p>I&rsquo;m not sure about you, but I would not describe &ldquo;the standard forward dynamic programming solution to maximum-likelihood decoding
of a discrete-time, finite-state dynamical system observed in memoryless noise&rdquo; with the word &ldquo;simple&rdquo;.</p><p>My goal for this article was to try to explain the Spotify Codes encoding process in an approachable way. If you have any questions please reach out and ask for clarification!</p><h2 id=further-reading>Further Reading<a hidden class=anchor aria-hidden=true href=#further-reading>#</a></h2><p><a href=https://zlib.net/crc_v3.txt>CRC Rocksoft</a></p><p><a href="https://trs.jpl.nasa.gov/bitstream/handle/2014/34531/94-0881.pdf?sequence=1">Reed-Solomon Codes and the Exploration of the Solar System</a></p><p><a href=https://doi.org/10.1109/TCOM.1984.1096047>High-Rate Punctured Convolutional Codes for Soft Decision Viterbi Decoding</a></p><p><a href=http://web.mit.edu/6.02/www/s2012/handouts/8.pdf>Viterbi Decoding of Convolutional Codes</a></p><p><a href=http://web.mit.edu/6.02/www/f2010/handouts/lectures/L8.pdf>Convolutional codes (MIT lecture notes)</a></p><p><a href=https://doi.org/10.1109/TIT.1967.1054010>Viterbi Decoder</a></p><p><a href=https://www.mathworks.com/help/comm/ug/punctured-convolutional-encoding-in-simulink.html>Punctured Convolutional Encoding</a></p><p><a href=https://ipnpr.jpl.nasa.gov/progress_report/42-63/63H.PDF>Performance of concatenated codes for deep space missions</a></p><p><a href=https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-02-introduction-to-eecs-ii-digital-communication-systems-fall-2012/lecture-slides/MIT6_02F12_lec06.pdf>Convolutional Codes and State Machine View/Trellis (MIT Slides)</a></p><p><a href=http://www.eccpage.com/>The Error Correcting Codes Page</a></p><p><a href=https://math.stackexchange.com/a/1284885>Explanation on Math Stack Exchange</a></p><p><a href=https://habr.com/en/post/518970/>Как спрятать мусор в базе Spotify и превратить это в квест (How to hide trash in Spotify database and turn it into a quest)</a></p><p><a href=https://dev.to/ale/cracking-spotify-codes-and-making-a-quest-out-of-it-3jdn>Cracking Spotify Codes and making a quest out of it</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://boonepeter.github.io/tags/tech>tech</a></li><li><a href=https://boonepeter.github.io/tags/spotify>spotify</a></li><li><a href=https://boonepeter.github.io/tags/python>python</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://boonepeter.github.io/>Peter Boone</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span>
<span>&#183;</span>
<span><a href=https://buttondown.email/boonepeter>Subscribe</a></span></footer><a href=#top aria-label="go to top" title="Go to Top" accesskey=g><button class=top-link id=top-link type=button><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6"><path d="M12 6H0l6-6z"/></svg></button></a>
<script src=https://boonepeter.github.io/assets/js/highlight.min.14feb2f019bbfe400c73e169354bb5dcbfab5cd41b3ee05da4cb155870a2914b.js integrity="sha256-FP6y8Bm7/kAMc+FpNUu13L+rXNQbPuBdpMsVWHCikUs="></script>
<script>hljs.initHighlightingOnLoad()</script><script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById("menu").scrollLeft=localStorage.getItem("menu-scroll-position"))},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${t}']`).scrollIntoView({behavior:"smooth"})})});var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById("menu").scrollLeft)}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>